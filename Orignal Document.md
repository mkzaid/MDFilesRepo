
# Python Network and Utility Modules

## M01:TCPNetLib

### Hex Code:
`A001`

### Suggested Module Names:

1. NetLibTCP  
2. PyTCPNet  
3. TCPNetworkLib  
4. TCPCommLib

### Module Description

* Automatic handling of connection setup, teardown, and reconnection attempts.  
* High-level functions for sending and receiving data as bytes, strings, or custom objects.  
* Built-in mechanisms for detecting and managing network errors, with customizable retry logic  
* Support for asynchronous communication using Python’s asyncio, enhancing scalability.

## M02:STUNClient

### Hex Code:
`A002`

### Suggested Module Names:

1. PySTUN  
2. STUNNet  
3. NATTraversal  
4. STUNTools

### Module Description:

* This module is used to get Ip Address, the type of NAT.  
* Determine if peer-to-peer connections are possible.  
* Enable direct communication between devices across different network environments.  
* Provide configuration to establish a connection in challenging network conditions.

## M03:ShadowsocksProxy

### Hex Code:
`A003`

### Suggested Module Names:

1. ShadowProxy  
2. Shadowsocks  
3. ProxySocks  
4. SecureProxy

### Module Description:

* Create shadowsocks proxies using this library.  
* This module used to protect privacy and bypass internet censorship    
* Allow us to create and manage Shadowsocks server and clients  
* Enable secure and encrypted communication over the internet  
* Allow us to secure API requests.  
* Configure the requests library to route HTTP requests through a Shadowsocks proxy, which can be useful for web scraping, API consumption, or other web interactions.

## M04:GateForward

### Hex Code:
`A004`

### Suggested Module Names:

1. PortForwarder  
2. NetGate  
3. PyForward  
4. GatewayRouter

### Module Description:

* Python tool for network port forwarding and gateway management  
* Allow us to set port forwarding rules, route traffic between different network interfaces  
* Manage gateways in a network environment  
* Control traffic flow within their network and manage network resources

## M05:SocketStatsAnalyze 

### Hex Code:
`A005`

### Suggested Module Names:

1. SocketMonitor  
2. NetSocketStats  
3. SocketTracker  
4. SocketInsight

### Module Description: 

* It Analyzes socket connections on your system.  
* Tracks active socket connections, including IP addresses and ports.  
* Also Monitors the state of each socket (e.g., established, listening).  
* And Provides statistics on data sent and received through each socket.  
* Useful for network administrators and developers to monitor and troubleshoot network connections.

## M06: PortAnalyzer

### Hex Code:
`A006`

### Suggested Module Names:

1. PortScanTool  
2. OpenPortScanner  
3. PortSecurityCheck  
4. PortInspector

## Module Description:

* It Scans and analyzes open ports in the system.  
* Identifies open ports and the services running on them.  
* Detects unauthorized or unusual port activity.  
* Provides a report of all open ports, including the associated application or process.  
* It also helps to ensure system security by identifying potential vulnerabilities related to open ports.

## M07: CPUAnalyzer

### Hex Code:
`A007`

### Suggested Module Names:

1. CPUPerfMonitor  
2. CPUUsageTracker  
3. SysCPUAnalyzer  
4. CPUInsight

## Module Description: 

* It Monitors and analyzes CPU usage and performance.  
* Tracks real-time CPU usage for each core.  
* Provides historical data on CPU load and temperature.  
* Analyzes CPU performance during specific tasks or over time.  
* It’s Ideal for optimizing system performance, identifying CPU bottlenecks, and ensuring efficient resource usage.

## M08: PacketCounter 

### Hex Code:
`A008`

### Suggested Module Names:

1. PacketMonitor  
2. NetPacketCounter  
3. PacketFlowStats  
4. NetworkPacketAnalyzer

## Module Description:

* It is used to count and analyze network packets.  
* It monitors the number of packets sent and received over the network.  
* Differentiates between types of packets (e.g., TCP, UDP).  
* Provides statistics on packet flow rates and data transfer.  
* Useful for network performance analysis, bandwidth monitoring, and identifying potential network issues.

## M09:FastTaskLaunch

### Hex Code:
`A009`

### Suggested Module Names:

1. TrayServer  
2. QuickServeIcon  
3. WebTrayLauncher  
4. TaskbarFastAPI

### Module Description

* FastTaskLaunch module is designed to streamline local development by integrating a FastAPI server with a taskbar icon for quick access  
* This module creates a taskbar icon that allows users to start a local FastAPI server with a single click.  
* Once the server is running, users can easily open their default web browser to the local server's URL by clicking a button on the taskbar icon.

## M10:WinTrack

### Hex Code:
`A010`

### Suggested Module Names:

1. WindowSpy  
2. MultiOSWindow  
3. ActiveWinScanner  
4. OSWindowLister

   ### 

### Module Description

* The WinTrack module is a cross-platform solution designed to retrieve the titles of active and open windows on a user's desktop  
* Monitor window activity across different operating systems, including Windows, macOS, and Linux.  
* WinTrack can identify the currently active window title and list all open window titles on the system, making it useful for automating tasks, tracking user activity, or integrating with other desktop applications. 

## M11:ScreenSnap

### Hex Code:
`A011`

### Suggested Module Names:

1. SnapShotter  
2. ScreenCap  
3. AutoScreenSave  
4. ScreenCapturePro

### Module Description

* The ScreenSnap module is a lightweight and versatile tool for capturing screenshots and saving them automatically to a designated folder.  
* The module generates timestamped filenames for each screenshot, ensuring that no two screenshots are overwritten. With support for different operating systems,  
* ScreenSnap is an ideal to automate the process of screen capturing.


## M12:KeyMouseTracker

### Hex Code:
`A012`

### Suggested Module Names:

1. InputMonitor  
2. PyInputLogger  
3. ActivityCapture  
4. MouseKeyMonitor

### Module Description 

* The InputMonitor module is a simple yet powerful tool for capturing and logging mouse and keyboard activity on your system.  
* It uses the pynput library, this module tracks every mouse click and key press, providing real-time feedback on user interactions.  
* Help us to monitor user behavior analysis, and input logging and can use its output in developing automated testing scripts,  
* InputMonitor offers to record input events across different operating systems. 

## M13:MouseMover

### Hex Code:
`A013`

### Suggested Module Names:

1. ClickAutomate  
2. PyMouseControl  
3. AutoClicker  
4. MouseMotion

### Module Description 

* The MouseMover module is a Python utility designed to automate mouse movements and clicks on your system.   
* MouseMover leverages the pynput library to provide a seamless and cross-platform solution

## M14:PySourceInspect 

### Hex Code:
`A014`

### Suggested Module Names:

1. PySourceInspect  
2. CodeReflector  
3. SourceAnalyzer  
4. PyCodeScanner  
5. InspectoPy

### Module Description

* The PySourceInspect module is a comprehensive tool for analyzing Python source code within a given folder.  
* Scanning all .py files provides detailed insights into the structure of the code, including lists of modules, classes, and functions defined in each file.   
* Additionally, it tracks the usage of functions, global variables, and class attributes across the codebase. The results are saved as JSON, allowing for easy review and further processing. 

## M15:ImageThrift

### Hex Code:
`A015`

### Suggested Module Names:

1. ImageThrift  
2. S3ThriftCache  
3. ThriftImageHandler  
4. ImageThriftServer

### Module Description

  make service/ module entry-todo/fill-in

  -thrift service

   

  -for images by path(s3)

  -images by uuid(s3)

  -vae by uuid

  -get hash from image uid

  -get uuid by hash

 -get path by uuid

  -cliph/ vector by uuid

  A thrift server that makes s3 requests and exposes APIS to thrift client

 -and benchmark

  -fill in details later

  –

  And cache client

  -saves results locally

  -and provide

   

* The ThriftImageService module is used to handle image retrieval and processing via a Thrift-based service.   
* The module interfaces with S3 to fetch images by path or UUID, compute hashes, retrieve vectors, and manage caching for improved performance.   
* The service is used to get hash by uuid, get uuid by hash, and get path by uuid.  
* It exposes a set of APIs through a Thrift server, allowing for easy interaction with Thrift clients.  
*  The server efficiently processes requests, caches results locally, and provides benchmark capabilities to evaluate performance. 


## M16:UDPHolePunch

### Hex Code:
`A016`

### Suggested Module Names:

1. PunchTest  
2. UDPHolePuncher  
3. NATHolePunch  
4. UDPConnect

### Module Description

* The UDPHolePunch module is a Python-based tool for testing UDP connectivity and NAT traversal techniques.   
* It includes a basic UDP server and client setup, along with methods to attempt UDP hole punching—a technique used to establish direct communication between peers in a NAT environment.  
*  The module is designed to understand the feasibility of direct peer-to-peer connections in various network configurations. 


## M17:ECCrypto

### Hex Code
`A017`

### Suggested Module Names:  
1. ECC SECP256K1 ### Hex Code:
2. Secp256k1 Tools  
3. ECCSigner  
4. Secp256k1 Utils

### Module Description

* The ECC SECP256K1 module provides essential cryptographic operations using Elliptic Curve Cryptography with the SECP256k1 curve.  
* This module allows for the generation of   
*    private   
*    public keys  
*    hashing of public keys using SHA-256   
*    signing of the hash  
*    verification of signatures.  
* By utilizing the ecdsa library, this module provides functionalities for secure key management and digital signature operations.

## M18:DiscScanner

### Hex Code:
`A018`

### Suggested Module Names:

1. DiskInspector  
2. DiscWriter  
3. MountPointChecker  
4. DiskUtil

### Module Description

* The DiscScanner module is a Python tool designed for disk inspection and management.   
* It scans all available disks, identifies their mount points  
* It Checks if the root folder is writable by the current user  
* The module includes functionality to write a JSON file containing a unique disk ID and UUID to the root of writable discs.

## M19:EventTracker

### Hex Code:
`A019`

### Suggested Module Names:

1. EventLogger  
2. EventSerializer  
3. EventManager  
4. SystemEvents

   ### 

### Module Description

* The EventTracker module is a Python library Handles and  
  manages computer events in Python.  
  Supports various event types, including:  
* New disk ID assignments.  
* Disk connections and disconnections.  
* Service shutdowns.  
* Connection starts and ends.


* Provides methods to serialize events to JSON and  
  deserialize JSON back into event objects.  
    
* Ideal for systems that need to track and log system events.  
* Enables efficient storage and retrieval of event data.

## M20:ScrapeMaster

### Hex Code:
`A020`

### Suggested Module Names:

1. DataExtractor  
2. ScraperSuite  
3. WebHarvest  
4. InfoScraper

### Module Description

* The ScrapeMaster module is a Python library designed for scraping data from various platforms and sources.  
*  It includes specialized classes for extracting information from YouTube, Pinterest, research papers, Telegram, Twitter, and general websites.   
* Each class is tailored to handle the specific structure of the respective platform's pages, providing a consistent interface for scraping and processing data.   
* The module supports extensibility, allowing for additional scrapers to be implemented as needed. It is ideal for data collection tasks, enabling users to efficiently gather and organize information from multiple online sources.


## M21:ServiceRegistry

### Hex Code:
`A021`

### Suggested Module Names:

1. ServiceManager  
2. ServiceDiscovery  
3. ServiceHub  
4. ServiceTracker

### Module Description

* The ServiceRegistry module provides a FastAPI-based service registry and recovery system.  
*  It enables clients to register and manage various types of services, computers, connections, transports, and routes in a distributed network.   
* With endpoints for service registration, listing known entities, and handling connections and transports, this module supports dynamic service discovery and management.  
*  It is designed for environments where service availability, connection management, and transport handling are crucial, offering a centralized way to track and interact with services in a networked system.

## M22: SurveyService 

### Hex Code:
`A022`

### Suggested Module Names:

* PySurvey  
* PollService  
* SurveyManager  
* FeedbackCollector

### Module Description:

* Python-based framework for creating, managing, and collecting survey responses.  
* Allows users to design customizable surveys with various question types, including:  
  * Multiple choice.  
  * Text input.  
  * Ratings.  
  * And more.  
* Offers an intuitive interface for distributing surveys to participants.  
* Collects responses in real time.  
* Collected data can be exported in various formats for easy analysis and reporting.  
* Ideal for researchers, businesses, and organizations conducting:  
  * Feedback gathering.  
  * Polls.  
  * Market research.  
* Supports integration with web applications through a RESTful API.  
* Enables seamless embedding of surveys within websites or mobile apps.  
* Includes features like:  
  * Response validation.  
  * Anonymous submissions.  
  * Result visualization for enhanced survey-taking experience.


## M23: ModelDownloader

### Hex Code:
`A023`

### Suggested Module Names:

* HuggingFaceModelManager  
* ModelFetch  
* PyModelDownloader  
* HuggingFaceLoader

### Module Description:


* Python tool designed to streamline downloading machine learning models from Hugging Face.  
* Automatically creates a "Models" folder and organizes downloaded model files into a subfolder named after the model (e.g., "Gemini 2B Pocket Tiger").  
* Computes a cryptographic hash for each file using the Blake2b hashing algorithm to ensure data integrity and security.  
* Generates a metadata file that includes:  
  * The name of the model's folder.  
  * A list of all downloaded files with their respective paths.  
  * The size of each file.  
  * The Blake2b hash of each file.  
* Provides a comprehensive summary of the downloaded model for easy verification and management.  
* Ideal for machine learning practitioners, researchers, and developers working with Hugging Face models, offering a convenient and secure way to manage model files.


# Coding Pattern

* The code will be in the Hex pattern for each module.  
* The code length will be a minimum of 4 digits.  
* For each new code, we will increment the last module code with 1.  
  E.g: if the last module code was A187 then the next module code will be A188.  
  But if the last module code is A999 then the next module code will be B001.


##  		Current Module and their codes

| Module Name | Code |
| :---- | :---- |
|   TCP Netlib| M01 |
|   STUNClient | M02 |
|   Shadowsocks Proxy | M03 |
|   GateForward | M04 |
|   SocketStats Analyzer | M05 |
|   Port Analyzer | M06 |
|   CPU Analyzer | M07 |
|   Pocket Counter | M08 |
| FastTaskLaunch | M09 |
| WinTrack | M10 |
| ScreenSnap | M11 |
| KeyMouseTracker | M12 |
| MouseOver | M13 |
| PySourceInspect | M14 |
| ImageThrift | M15 |
| UDPHolePunch | M16 |
| ECCrypto | M17 |
| DiscScanner | M18 |
| EventTracker | M19 |
| ScrapeMaster | M20 |
| ServiceRegistry | M21 |
| SurveyService | M22 |
| ModelDownloader | M23 |

# Description of screenshots

```python
from pydantic import BaseModel, Field, HttpUrl 
import datetime
import numpy as np
from uuid_generator import generate_uuid

class SearchResult(BaseModel):
    type: str = "SearchResult"
    uuid: np.int64
    video_title: str
    video_id: str
    video_url: HttpUrl
    video_view_count: int
    video_date: str
    video_likes: int
    channel_url: HttpUrl
    video_duration: int
    video_number_of_subscribers: int
    video_subtitles_available: bool = False
    video_published_date: str
    video_description: str = None

# Example usage
uuid = np.int64(generate_uuid(datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.&f")))
search_result_data = {
    "uuid": uuid,
    "video_title": "Web Scraping vs Web Crawling Explained",
    "video_id": "TLosoD249NA",
    "video_url": "https://www.youtube.com/watch?v=TLosoD249NA", 
    "video_view_count": 31942,
    "video_date": "2020-06-24T00:00:00.000Z",
    "video_likes": 477,
    "channel_url": "https://www.youtube.com/@zytedata",
    "video_number_of_subscribers": 3798,
    "video_duration": "00:03:14",
    "video_subtitles_available": True,
    "video_published_date": "2020-06-20T00:00:00.000Z",
    "video_description": "An explanation of the differences between web scraping and web crawling."
}

# Create an instance of SearchResult
search_result = SearchResult(**search_result_data)

# Convert to JSON
json_str = search_result.json()
print(json_str)

# Parse from JSON
parsed_result = SearchResult.parse_raw(json_str)
print(parsed_result)
```

## **SearchResult** 

This  Python code snippet involves the use of the pedantic library for creating a data model called SearchResult. Here's a breakdown of the code:

### 1. Import some important libraries and why we use them

* BaseModel, Field, and HttpUrl are imported from pedantic.  
* datetime is used to work with date and time.  
* numpy is imported as np and used for handling numerical operations.  
* A custom module uuid_generator is imported to generate UUIDs using the function generate_uuid.

### 2. Class for storing details of all search results

  (SearchResult):

* A class SearchResult is defined, which inherits from BaseModel. This class represents a model for storing and validating the details of a video search result.  
* The class contains several attributes:  
  * uuid: A unique identifier for the search result (64-bit integer).  
  * video_title: The title of the video (string).  
  * video_id: The unique ID of the video (string).  
  * video_url: The URL of the video (HTTP URL).  
  * video_view_count: The number of views the video has received (integer).  
  * video_date: The date the video was published (string).  
  * video_likes: The number of likes the video has received (integer).  
  * channel_url: The URL of the channel that uploaded the video (HTTP URL).  
  * video_number_of_subscribers: The number of subscribers of the channel (integer).  
  * video_duration: The duration of the video (integer, likely in seconds).  
  * video_subtitles_available: A boolean indicating whether subtitles are available for the video.  
  * video_published_date: The date the video was published (string).  
  * video_description: A brief description of the video (string, optional, and can be None).

### 3. Example Usage:

* **UUID Generation**:  
  * A unique UUID is generated by combining a datetime string with a custom UUID generation function.  
* **Data Dictionary**:  
  * An example dictionary search_result_data is provided, containing details about a specific video.  
* **Creating an Instance**:  
  * An instance of SearchResult is created using the ** operator to unpack the search_result_data dictionary into the class.  
* **Converting to JSON**:  
  * The instance is then converted to a JSON string using the .json() method.  
* **Parsing from JSON**:  
  * The JSON string is parsed back into a SearchResult instance using the parse_raw method.

  It demonstrates how to define a data model using pedantic to validate and manage video search results. It shows how to generate a UUID, create an instance of the model, serialize it to JSON, and then deserialize it back into a Python object.

 ```python
from pydantic import BaseModel, Field, ValidationError, validator
import datetime
import numpy as np
from typing import List, Optional
from uuid_generator import generate_uuid

class VideoPageData(BaseModel):
    type: str = "VideoPageData"
    uuid: np.int64
    video_id: str
    video_url: str
    video_title: str
    video_thumbnail: str
    video_description: str
    channel_id: str
    video_resolutions: List[str]
    video_metadata: dict
    video_scraped: bool
    video_published_date: str
    video_data_field: Optional[str]

# Example usage
uuid = np.int64(generate_uuid(datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.&f")))
video_data = {
    "uuid": uuid,
    "video_id": "KaXJDKCvbHY",
    "video_url": "https://youtu.be/KaXJDKCvbHY",
    "video_title": "Sample Video",
    "video_thumbnail": "http://example.com/thumbnail.jpg",
    "video_description": "This is a sample video description.",
    "channel_id": "channel123",
    "video_resolutions": ["1080p", "720p"],
    "video_metadata": {
        "views": 1000,
        "likes": 100,
        "dislikes": 10,
        "publishedAt": "2023-01-01T00:00:00Z",
        "duration": "00:03:14"
    },
    "video_scraped": True,
    "video_published_date": "2023-01-01T12:00:00Z",
    "video_data_field": "additional data"
}

# Create an instance of VideoPageData
video_page_data = VideoPageData(**video_data)

# Convert to JSON
json_str = video_page_data.json()
print(json_str)

# Parse from JSON
parsed_data = VideoPageData.parse_raw(json_str)
print(parsed_data)
```

  ## **VideoPageData** 

  Here with the help of the pedantic library for creating a data model called VideoPageData. Here's a detailed explanation:

### 1. Importing some importing dependencies

* BaseModel, Field, ValidationError, and validator are imported from pedantic.  
* List and Optional are imported from typing for type annotations.  
* datetime for handling date and time operations.  
* numpy as np for numerical operations.  
* A custom module uuid_generator is used to generate UUIDs via a function generate_uuid.

### 2. Class for storing all information on the video page(VideoPageData):

* A class VideoPageData is defined, which inherits from BaseModel. This class represents a model for storing and validating detailed information about a video page.  
* The class includes several attributes:  
  * uuid: A unique identifier for the video page (64-bit integer).  
  * video_id: The unique ID of the video (string).  
  * video_url: The URL of the video (string).  
  * video_title: The title of the video (string).  
  * video_thumbnail: The URL of the video’s thumbnail (string).  
  * video_description: A brief description of the video (string).  
  * channel_id: The ID of the channel that uploaded the video (string).  
  * video_resolutions: A list of available video resolutions (list of strings).  
  * video_metadata: A dictionary containing additional metadata about the video (dictionary).  
  * video_scraped: A boolean indicating if the video data has been scraped.  
  * video_published_date: The date the video was published (string).  
  * video_data_field: An optional field for storing additional video-related data (optional list of strings).

### 3. Example Usage:

* UUID Generation:  
  * A unique UUID is generated by combining a datetime string with a custom UUID generation function.  
* **Data Dictionary**:  
  * An example dictionary video_data is provided, containing comprehensive details about a specific video, including its resolutions and metadata.  
* **Creating an Instance**:  
  * An instance of VideoPageData is created using the ** operator to unpack the video_data dictionary into the class.  
* **Converting to JSON**:  
  * The instance is then serialized to a JSON string using the `.json()` method.  
* **Parsing from JSON**:  
  * The JSON string is parsed back into a VideoPageData instance using the parse_raw method.

  **Summary:**

  It demonstrates how to define a more complex data model using `pedantic` to manage detailed information about a video page. The model includes multiple fields, some of which are optional or contain lists or dictionaries. The code shows how to generate a UUID, create an instance of the model with detailed video data, serialize it to JSON, and then deserialize it back into a Python object.


```python
from pydantic import BaseModel, Field
import datetime
import numpy as np
from uuid_generator import generate_uuid

class ChannelVideo(BaseModel):
    type: str = "ChannelVideo"
    uuid: np.int64
    channel_uuid: int
    video_uuid: int

# Example usage
channel_uuid = np.int64(generate_uuid(datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")))
video_uuid = np.int64(generate_uuid(datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")))

channel_video_data = {
    "channel_uuid": channel_uuid,
    "video_uuid": video_uuid,
}

# Create an instance of ChannelVideo
channel_video = ChannelVideo(**channel_video_data)

# Convert to JSON
json_str = channel_video.json()
print(json_str)

# Parse from JSON
parsed_channel_video = ChannelVideo.parse_raw(json_str)
print(parsed_channel_video)
```

  ##  **ChannelVideo**

  Now we again use the `pedantic` library for creating a simple data model called ChannelVideo. Here's a detailed explanation:

  ### 1. Imports:

* BaseModel and Field are imported from pedantic for creating data models.  
* datetime for working with date and time.  
* numpy as np for numerical operations.  
* A custom module uuid_generator is imported to generate UUIDs using the function generate_uuid.

### 2. Class for associating a video with a specific channel(ChannelVideo):

* A class `ChannelVideo` is defined, which inherits from `BaseModel`. This class represents a model for associating a video with a specific channel.  
* The class includes three attributes:  
  * uuid: A unique identifier for the channel-video association (64-bit integer).  
  * channel_uuid: The UUID of the channel (64-bit integer).  
  * video_uuid: The UUID of the video (64-bit integer).

### 3. Example Usage:

* **UUID Generation**:  
  * Two unique UUIDs are generated, one for the channel and one for the video, by combining datetime strings with a custom UUID generation function.  
* **Data Dictionary**:  
  * An example dictionary channel_video_data is provided, containing the channel_uuid and video_uuid.  
* **Creating an Instance**:  
  * An instance of ChannelVideo is created using the ** operator to unpack the channel_video_data dictionary into the class.  
* **Converting to JSON**:  
  * The instance is then serialized to a JSON string using the `.json()` method.  
* **Parsing from JSON**:  
  * The JSON string is parsed back into a ChannelVideo instance using the parse_raw method.

  **Summary:**

  Here we are defining a straightforward data model using `pedantic` to manage the relationship between a channel and a video. The model includes only three fields: a UUID for the channel-video association, a UUID for the channel, and a UUID for the video. The code shows how to generate UUIDs, create an instance of the model, serialize it to JSON, and then deserialize it back into a Python object.


```python
from pydantic import BaseModel, Field, HttpUrl
import datetime
import numpy as np
from uuid_generator import generate_uuid

class Channel(BaseModel):
    type: str = "Channel"
    uuid: np.int64
    channel_url: HttpUrl

# Example usage
uuid = np.int64(generate_uuid(datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")))
channel_data = {
    "uuid": uuid,
    "channel_url": "https://www.youtube.com/@zytedata",
}

# Create an instance of Channel
channel = Channel(**channel_data)

# Convert to JSON
json_str = channel.json()
print(json_str)

# Parse from JSON
parsed_channel = Channel.parse_raw(json_str)
print(parsed_channel)
```

  ## **Channel**

  Here we create and manage a `"Channel"` object using the `pedantic` library, which is useful for data validation and settings management. Below is a detailed breakdown of the code:

### 1. Importing Necessary Dependencies:

* **BaseModel, Field, and HttpUrl from pedantic**: These are used to define and validate data models. BaseModel serves as the base class, Field is used for setting default values and validation rules, and HttpUrl is a specialized field type for validating URLs.  
* **datetime**: For handling date and time operations, particularly when generating a unique identifier (UUID).  
* **numpy as np**: Imported for numerical operations, specifically to ensure the UUID is treated as a 64-bit integer.  
* **generate_uuid from uuid_generator**: A custom function used to generate a UUID based on the current date and time.

### 2. Class for Storing Channel Information (Channel):

* A class Channel is defined, which inherits from BaseModel. This class serves as a model for storing and validating information about a channel.  
  The class includes the following attributes:  
  * **type**: A string with a default value of "Channel", indicating the type of the object.  
  * **uuid**: A unique identifier for the channel, stored as a 64-bit integer (np.int64).  
  * **channel_url**: The URL of the channel, validated as a valid URL using the HttpUrl type.

### 3. Example Usage:

* **UUID Generation**:  
  * A unique UUID is generated by combining the current date and time (formatted as a string) with the custom generate_uuid function. This UUID is then converted to a 64-bit integer.  
* **Data Dictionary**:  
  * An example dictionary, channel_data, is provided, which contains the generated uuid and a channel_url.  
* **Creating an Instance**:  
  * An instance of the Channel class is created using the ** operator to unpack the channel_data dictionary into the class.  
* **Converting to JSON**:  
  * The Channel instance is serialized to a JSON string using the `.json()` method. This allows the instance to be easily converted to a format suitable for storage or transmission.  
* **Parsing from JSON**:  
  * The JSON string is parsed back into a Channel instance using the parse_raw method, demonstrating how to deserialize the JSON data back into a Python object.

  **Summary:**

  This script demonstrates how to define a data model using pydantic to manage and validate information about a channel. The model includes a few key fields, such as a UUID and a validated URL, making it robust for handling channel data. The example usage shows how to generate a UUID, create an instance of the model, serialize it to JSON, and then deserialize it back into a Python object.


```python
from pydantic import BaseModel, Field, HttpUrl
import datetime
import numpy as np
from uuid_generator import generate_uuid

class VideoPage(BaseModel):
    type: str = "VideoPage"
    uuid: np.int64
    video_url: HttpUrl

# Example usage
uuid = np.int64(generate_uuid(datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")))
video_page = {
    "uuid": uuid,
    "video_url": "https://www.youtube.com/watch?v=TLosoD249NA",
}

# Create an instance of VideoPage
video_page = VideoPage(**video_page)

# Convert to JSON
json_str = video_page.json()
print(json_str)

# Parse from JSON
parsed_video_page = VideoPage.parse_raw(json_str)
print(parsed_video_page)
```


  ## **Python script**

  Here we have a Python script for creating and managing a `VideoPage` data model using the `pydantic` library. Here's a detailed explanation:

---

### 1. Importing Necessary Dependencies:

* **BaseModel, Field, and HttpUrl from pydantic**: These are used to define and validate data models. BaseModel is the base class, Field is used for defining fields with validation rules, and HttpUrl is a specialized field type that ensures the value is a valid URL.  
* **datetime**: For working with date and time, particularly useful when generating unique identifiers (UUIDs).  
* **numpy as np**: A library for numerical operations, here specifically used to handle the UUID as a 64-bit integer.

  **generate_uuid from uuid_generator**: A custom function likely used to generate a unique identifier (UUID).

### 2. Class for Storing Video Page Information (VideoPage):

* A class VideoPage is defined, which inherits from BaseModel. This class serves as a model for storing and validating the essential information related to a video page.  
  The class includes the following attributes:  
  * **type**: A string with a default value of "VideoPage", indicating the type of the object.  
  * **uuid**: A unique identifier for the video page, stored as a 64-bit integer (np.int64).  
  * **video_url**: The URL of the video, validated as a proper URL using the HttpUrl type.

### 3. Example Usage:

* **UUID Generation**:  
  * A unique UUID is generated by combining the current date and time (formatted as a string) with the custom generate_uuid function. This UUID is then converted to a 64-bit integer.  
* **Data Dictionary**:  
  * An example dictionary, video_page, is provided, containing the generated uuid and a video_url.  
* **Creating an Instance**:  
  * An instance of the VideoPage class is created using the ** operator to unpack the video_page dictionary into the class.  
* **Converting to JSON**:  
  * The VideoPage instance is serialized to a JSON string using the `.json()` method, making it easy to store or transmit the data.  
* **Parsing from JSON**:  
  * The JSON string is parsed back into a VideoPage instance using the parse_raw method, demonstrating how to deserialize the JSON data back into a Python object.

  **Summary:**

  This script demonstrates how to define a VideoPage data model using pydantic to manage and validate information about a video page. The model includes fields such as a UUID and a validated URL, making it suitable for handling video-related data. The example shows how to generate a UUID, create an instance of the model, serialize it to JSON, and then deserialize it back into a Python object.

```python
import secrets
from datetime import datetime, timezone
from typing import List

class Uuid64:
    _value: int = 0

    def __init__(self):
        # Create with the current UTC date.
        self._create_value_with_date(datetime.now(timezone.utc))

    def __str__(self):
        hex_string = self._value.to_bytes(8, 'big').hex()
        return (hex_string[0:4] + '-' + hex_string[4:8] + '-' + hex_string[8:12] + '-' + hex_string[12:16]).upper()

    @staticmethod
    def from_date_string(date: str, date_formats: List[str]):
        if not date_formats:
            raise ValueError(f"date_formats must include at least one format")
        for fmt in date_formats:
            try:
                date_value = datetime.strptime(date, fmt)
                break
            except ValueError:
                continue
        else:
            raise ValueError(f"time data '{date}' does not match any of the provided formats")
        instance = Uuid64()
        instance._create_value_with_date(date_value)
        return instance

    @staticmethod
    def from_mongo_value(value: int):
        if value < 0 or value > 18446744073709551615:
            raise ValueError(f"the value is not a valid uuid")
        instance = Uuid64()
        instance._value = value
        return instance

    def to_mongo_value(self):
        return self._value

    def to_formatted_str(self):
        return str(self)

    def _create_value_with_date(self, date_value: datetime):
        unix_time_32bit = int(date_value.timestamp()) & 0xFFFFFFFF
        random_32bit = int(secrets.randbits(32)) & 0xFFFFFFFF
        self._value = (random_32bit & 0xFFFFFFFF) | (unix_time_32bit << 32)
```
  ## **Uuid64**

  It shows the implementation of a `Uuid64` class in Python, which is designed to generate and manipulate 64-bit UUIDs based on date and time. Here's a detailed explanation of the class and its methods:

  ---

### 1. Class (Uuid64):

  **class Uuid64:**: This defines the Uuid64 class, which handles the creation and management of a 64-bit UUID. The class contains various methods for initializing, formatting, and converting the UUID.

### 2. Initialization (__init__ Method):

* **def __init__(self):**: This is the constructor method that initializes an instance of Uuid64.  
  * **self._value: int = 0**: A private attribute _value is initialized to 0. This will later hold the 64-bit UUID.  
  * **self._create_value_with_date(datetime.now(timezone.utc))**: This method is called during initialization to create a UUID based on the current UTC date and time.

### 3. String Representation (__str__ Method):

* **def __str__(self):**: This method returns a string representation of the UUID in a typical UUID format.  
  * The _value is converted to a hexadecimal string and then divided into chunks separated by hyphens to follow the UUID format (e.g., 123e4567-e89b-12d3-a456-426614174000).

### 4. Static Method: from_date_string:

* **@staticmethod def from_date_string(date: str, date_formats: List[str])**: This method creates a Uuid64 instance from a date string using one of the provided date formats.  
  * **Date Parsing**: It tries to parse the date string using each format in date_formats. If successful, the date is converted to a datetime object.  
  * **Instance Creation**: A new Uuid64 instance is created, and the _create_value_with_date method is called with the parsed date to generate the UUID.

### 5. Static Method: from_mongo_value:

* **@staticmethod def from_mongo_value(value: int)**: This method creates a Uuid64 instance from a 64-bit integer value (commonly used in MongoDB).  
  * **Validation**: It checks if the provided value is valid by comparing it to a predefined threshold (18446744073709551615). If not valid, it raises a ValueError.  
  * **Instance Creation**: A new Uuid64 instance is created, and its _value is set to the provided integer.

### 6. Conversion to MongoDB Value (to_mongo_value Method):

* **def to_mongo_value(self):**: This method returns the UUID value as an integer, suitable for storing in MongoDB.

### 7. Formatted String Conversion (to_formatted_str Method):

  **def to_formatted_str(self)::** This method returns the UUID as a formatted string, similar to what the __str__ method does.

### 8. Creating Value with Date (_create_value_with_date Method):

* **def _create_value_with_date(self, date_value: datetime)**: This method generates the 64-bit UUID using the provided date.  
  * **POSIX Time**: The timestamp of the date is converted into a 32-bit unsigned integer.  
  * **Random Number Generation**: A secure 32-bit random number is generated.  
  * **UUID Composition**: The final 64-bit UUID is composed by combining the 32-bit time value and the 32-bit random number.

  **Summary:**

  The Uuid64 class is a custom implementation for generating and manipulating 64-bit UUIDs based on date and time. It allows for creating UUIDs from the current time, a specific date string, or a MongoDB value. The class also provides methods for converting the UUID to a string format and a MongoDB-compatible integer format. This implementation is useful in systems where a compact and time-based unique identifier is required.


  

# Project KCG

### **C# Module**

**1:** Get git checkpoint hash and commit number and branch for kcg-game, kcg-lib, kcg-map, kcg-arena.

**2:** On the run, have computer UUID

**3:** On each run produce a log file with uuid at top

**4:** spawn thread or process to communicate with the remote server and give a list of uuid for logs and upload any logs the server does not already have.

**5:** log file named by `log-uuid.py`

**6:** Web app to see all logs, and by computer

## **LibGit2Sharp**

* Retrieve information about the repository, such as the branch name, latest commit hash, etc.  
* Clone a remote Git repository to a local directory.  
* Initialize a new Git repository in a specified directory.  
* Remove a Git repository from a directory.  
* Access commit details including the author, commit message, and date.  
* Create new branches or delete existing ones.  
* Check out a specific branch in the repository.  
* Stage changes and create commits with messages.  
* Modify the most recent commit  
* Add new remote repositories or remove existing ones.  
* Fetch updates from a remote repository or push local changes.  
* Create new tags or delete existing ones.  
* Retrieve a list of tags in the repository.  
* Apply changes from specific commits onto the current branch.  
* Get line-by-line information about who last modified each line of a file.  
* Search for commits based on criteria like author, date, or commit message.  
  


## **Computer UUID**

* When the computer runs, then use System. Management library To capture the UUID of the computer.

## **Creating Log file**

* On each run,use the `System.IO` library, which provides classes for working with file input and output. In particular, the `StreamWriter` class is used to write text to a file.  
* Obtain the UUID of the computer. This UUID is a unique identifier assigned to the machine.  
* Generate a log file where the UUID is included at the very top of the file. This can help associate the log file with a specific machine or instance.  
* After writing the UUID at the top of the file, append the actual log data below it. This ensures that anyone reading the log file knows which machine the logs are associated with.  
* Store Log file by name log-uuid

## **Spawn Thread**

* Use HTTPClient  to spawn a thread or process to communicate with a remote server in C#  
* Use Task for background Threads  
* Retrieve a list of UUIDs from a local source.  
* For each UUID, send a log file to the remote server if the server does not already have it.  
* Use Task to perform these operations asynchronously.

## **View All Logs**

###  **For computer**

* To see logs in a computer, create a simple Windows Forms or WPF application that reads the log files from the disk and displays the content in a TextBox or RichTextBox.  
* Use  System.Windows.Forms library 

### **For web apps**

* For a web page, create a simple web interface that reads log files from the server and displays them on a web page.  
* Create a controller that reads the log files and passes the content to the view.  
* Add a view (Razor page) that displays the log content.

## 


  


  


  


